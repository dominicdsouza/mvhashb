package com.hash.mvhashb;

public class match {

	/*
	 * Function: new_match_bloom Description: Match two hashes generated by mvHash-B. The input to this function is the
	 * uint8_t-arrays of the hashes. Input: file 1 - pointer to an uint8_t hash of file 1. size_file1 - number of elements in the
	 * uint8_t hash of file 1. file 2 - pointer to an uint8_t hash of file 2. size_file2 - number of elements in the uint8_t hash of
	 * file 2. elements_pr_bf - the number of elements per Bloom filter used when the hashes were created. Return: The result of the
	 * comparison, in a scale from 0-100.
	 *
	 */
	/*
	 * Author: Knut Petter Åstebøl Date: 29. December 2012 Version: 2.0.
	 */

	// Functions used to compare two hashes.

	/*
	 * Author: Knut Petter Åstebøl Date: 29. December 2012 Version: 2.0.
	 */

	// Functions used to compare two hashes.

	public static double new_match_bloom(int[] file1, int size_file1, int[] file2, int size_file2, int elements_pr_bf) {
		// C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
		// ORIGINAL LINE: byte *fileA = file1;
		int[] fileA = file1;
		int size_fileA = (int) size_file1; // The size of the file in terms of the number of uint8-elements.
		int A_bloom_filter_number;

		// C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
		// ORIGINAL LINE: byte *fileB = file2;
		int[] fileB = file2;
		int size_fileB = (int) size_file2; // The size of the file in terms of the number of uint8-elements.
		int B_bloom_filter_number;

		// file_to_uint8(filename_A, &fileA, &size_fileA);
		// file_to_uint8(filename_B, &fileB, &size_fileB);

		if (((size_fileA % 256) != 0) || ((size_fileB % 256) != 0)) {
			System.out.print("Invalid size of bloom filter file. Exiting. \n");
			System.exit(1);
		}

		// A must be the smallest one.
		if (size_fileA > size_fileB) {
			// C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
			// ORIGINAL LINE: byte *temp_uint;
			int[] temp_uint;
			int temp_file_size;

			temp_uint = fileA;
			temp_file_size = size_fileA;

			fileA = fileB;
			size_fileA = size_fileB;

			fileB = temp_uint;
			size_fileB = temp_file_size;
		}

		A_bloom_filter_number = size_fileA / 256;
		B_bloom_filter_number = size_fileB / 256;

		int[] bits = new int[256];
		int i;

		// Compute the bits array. The value of byte number i is the number of ones within a byte with the value i.
		for (i = 0; i < 256; i++) {
			bits[i] = unit8.numb_bits_in_byte(i);
		}

		int j;
		int k;
		int hamming_current;
		double hamming_similar;
		double hamming_total = 0;
		double ip;
		int temp;
		int ones_in_A;
		int ones_in_B;
		double hamming_percent;

		double numb_bloom_filters_in_smallest = Math.min(size_fileA, size_fileB) / 256;

		if ((size_fileB / size_fileA) > 4) {
			hamming_percent = -1;
		}

		else if ((B_bloom_filter_number - A_bloom_filter_number) > 4) {
			hamming_percent = -1;
		}

		else {
			for (i = 0; i < A_bloom_filter_number; i++) {

				// Count number of 1s in Bloom-filter A[i].
				ones_in_A = 0;
				for (k = 0; k < 256; k++) {
					ones_in_A += bits[fileA[i * 256 + k]];
				}

				if (ones_in_A > elements_pr_bf) {
					System.out.print("Number of ones in A too big. Exiting. \n");
					System.exit(1);
				}

				hamming_similar = 100;
				for (j = 0; j < B_bloom_filter_number; j++) {
					// Count number of 1s in Bloom-filter B[j].
					ones_in_B = 0;
					for (k = 0; k < 256; k++) {
						ones_in_B += bits[fileB[j * 256 + k]];
					}

					if (ones_in_B > elements_pr_bf) {
						System.out.print("Number of ones in B too big. Exiting. \n");
						System.exit(1);
					}

					hamming_current = 0;
					for (k = 0; k < 256; k++) {
						temp = fileA[i * 256 + k] ^ fileB[j * 256 + k];
						hamming_current += bits[temp];
					}

					if (hamming_current == 0) {
						ip = 0; // Individual percent.
					} else {
						ip = ((100 * hamming_current) / (ones_in_A + ones_in_B)) * 2.5;
					}

					if (ip < hamming_similar) {
						hamming_similar = ip;
					}

				}

				hamming_total += hamming_similar;

			}

			hamming_percent = 100 - (hamming_total / numb_bloom_filters_in_smallest);

		}

		// printf("%d\n", hamming_percent);
		System.out.println(hamming_percent);
		return hamming_percent;
	}

	/*
	 * Function: match_bloom Description: Match two hashes generated by mvHash-B. Input: filename_A filename_B elements_pr_bf - the
	 * number of elements pr Bloom filter used when the hashes was created. Return: The result of the comparison, in a scale from
	 * 0-100.
	 *
	 */

	// public static int match_bloom(tangible.RefObject<String> filename_A, tangible.RefObject<String> filename_B,
	// int elements_pr_bf) {
	// // C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
	// // ORIGINAL LINE: byte *fileA = null;
	// byte fileA = 0;
	// int size_fileA; // The size of the file in terms of the number of uint8-elements.
	// int A_bloom_filter_number;
	//
	// // C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
	// // ORIGINAL LINE: byte *fileB = null;
	// byte fileB = 0;
	// int size_fileB; // The size of the file in terms of the number of uint8-elements.
	// int B_bloom_filter_number;
	//
	// tangible.RefObject<Integer> tempRef_size_fileA = new tangible.RefObject<Integer>(size_fileA);
	// file_to_uint8(filename_A, fileA, tempRef_size_fileA);
	// size_fileA = tempRef_size_fileA.argValue;
	// tangible.RefObject<Integer> tempRef_size_fileB = new tangible.RefObject<Integer>(size_fileB);
	// file_to_uint8(filename_B, fileB, tempRef_size_fileB);
	// size_fileB = tempRef_size_fileB.argValue;
	//
	// if (((size_fileA % 256) != 0) || ((size_fileB % 256) != 0)) {
	// System.out.print("Invalid size of bloom filter file. Exiting. \n");
	// System.exit(1);
	// }
	//
	// // A must be the smallest one.
	// if (size_fileA > size_fileB) {
	// // C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
	// // ORIGINAL LINE: byte *temp_uint;
	// byte temp_uint;
	// int temp_file_size;
	//
	// temp_uint = fileA;
	// temp_file_size = size_fileA;
	//
	// fileA = fileB;
	// size_fileA = size_fileB;
	//
	// fileB = temp_uint;
	// size_fileB = temp_file_size;
	// }
	//
	// A_bloom_filter_number = size_fileA / 256;
	// B_bloom_filter_number = size_fileB / 256;
	//
	// int[] bits = new int[256];
	// int i;
	//
	// // Compute the bits array. The value of byte number i is the number of ones within a byte with the value i.
	// for (i = 0; i < 256; i++) {
	// bits[i] = numb_bits_in_byte(i);
	// }
	//
	// int j;
	// int k;
	// int hamming_current;
	// int hamming_similar;
	// int hamming_total = 0;
	// int ip;
	// int temp;
	// int ones_in_A;
	// int ones_in_B;
	// int hamming_percent;
	//
	// int numb_bloom_filters_in_smallest = Math.min(size_fileA, size_fileB) / 256;
	//
	// if ((size_fileB / size_fileA) > 4) {
	// hamming_percent = -1;
	// }
	//
	// else if ((B_bloom_filter_number - A_bloom_filter_number) > 4) {
	// hamming_percent = -1;
	// }
	//
	// else {
	// for (i = 0; i < A_bloom_filter_number; i++) {
	//
	// // Count number of 1s in Bloom-filter A[i].
	// ones_in_A = 0;
	// for (k = 0; k < 256; k++) {
	// ones_in_A += bits[fileA[i * 256 + k]];
	// }
	//
	// if (ones_in_A > elements_pr_bf) {
	// System.out.print("Number of ones in A too big. Exiting. \n");
	// System.exit(1);
	// }
	//
	// hamming_similar = 100;
	// for (j = 0; j < B_bloom_filter_number; j++) {
	// // Count number of 1s in Bloom-filter B[j].
	// ones_in_B = 0;
	// for (k = 0; k < 256; k++) {
	// ones_in_B += bits[fileB[j * 256 + k]];
	// }
	//
	// if (ones_in_B > elements_pr_bf) {
	// System.out.print("Number of ones in B too big. Exiting. \n");
	// System.exit(1);
	// }
	//
	// hamming_current = 0;
	// for (k = 0; k < 256; k++) {
	// temp = fileA[i * 256 + k] ^ fileB[j * 256 + k];
	// hamming_current += bits[temp];
	// }
	//
	// if (hamming_current == 0) {
	// ip = 0; // Individual percent.
	// } else {
	// ip = ((100 * hamming_current) / (ones_in_A + ones_in_B));
	// }
	//
	// if (ip < hamming_similar) {
	// hamming_similar = ip;
	// }
	//
	// }
	//
	// hamming_total += hamming_similar;
	//
	// }
	//
	// hamming_percent = 100 - (hamming_total / numb_bloom_filters_in_smallest);
	//
	// }
	//
	// System.out.printf("%d\n", hamming_percent);
	//
	// return hamming_percent;
	// }

	/*
	 * Function: match8 Description: Computes the similarity between two files and outputs a score. The score is computed by using
	 * Levensthein distance. This function is designed to be used when there was used RLE-width of 1B to generate the hash. Input:
	 * filename_A - filename_B - Return: The result of the comparison of the files, at a scale from 0-100.
	 *
	 */

	// public static int match8(tangible.RefObject<String> filename_A, tangible.RefObject<String> filename_B) {
	// int output;
	// int output_levensthein;
	// int output_frag_percent; // Fragmentation detection.
	// int output_frag_abs;
	// int lower_bound;
	// int upper_bound;
	//
	// // C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
	// // ORIGINAL LINE: byte *fileA = null;
	// byte fileA = 0;
	// int size_fileA; // The size of the file in terms of the number of uint8-elements.
	//
	// // C++ TO JAVA CONVERTER TODO TASK: Java does not have an equivalent to pointers to value types:
	// // ORIGINAL LINE: byte *fileB = null;
	// byte fileB = 0;
	// int size_fileB; // The size of the file in terms of the number of uint8-elements.
	//
	// // The files are added to uint8-arrays.
	// tangible.RefObject<Integer> tempRef_size_fileA = new tangible.RefObject<Integer>(size_fileA);
	// file_to_uint8(filename_A, fileA, tempRef_size_fileA);
	// size_fileA = tempRef_size_fileA.argValue;
	// tangible.RefObject<Integer> tempRef_size_fileB = new tangible.RefObject<Integer>(size_fileB);
	// file_to_uint8(filename_B, fileB, tempRef_size_fileB);
	// size_fileB = tempRef_size_fileB.argValue;
	//
	// lower_bound = Math.abs(size_fileA - size_fileB);
	// upper_bound = Math.max(size_fileA, size_fileB);
	//
	// output_levensthein = lev_edit_distance(size_fileA, fileA, size_fileB, fileB, 0);
	//
	// // Check that nothing has gone wrong in the computation.
	// if ((output_levensthein < lower_bound) || (output_levensthein > upper_bound)) {
	// System.out.print("Error while calculating Levensthein distance. Exiting. \n");
	// System.exit(1);
	// }
	//
	// // Compute the match value in percent.
	// output = 100 - ((output_levensthein * 100) / upper_bound);
	//
	// // Fragmentation detection.
	// output_frag_percent = 100 - ((100 * (output_levensthein - lower_bound)) / (upper_bound - lower_bound));
	// output_frag_abs = output_levensthein - lower_bound;
	//
	// System.out.printf("%d\n", output);
	//
	// // Terminating
	// // C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
	// free(fileA);
	// // C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
	// free(fileB);
	//
	// return output;
	// }

	// C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	// int match(tangible.RefObject<String> filename_A, tangible.RefObject<String> filename_B);

	// C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	// int levenshtein_distance(tangible.RefObject<ushort> s, int s_size, tangible.RefObject<ushort> t, int t_size);

	/*
	 * Function: minimum Description: Computes the minimum of three integer values. Input: a b c Return: The minimum of the three
	 * values.
	 *
	 */

	public static int minimum(int a, int b, int c) {
		int min = a;
		if (b < min) {
			min = b;
		}
		if (c < min) {
			min = c;
		}
		return min;
	}

	/*
	 * Function: max Description: Computes the maximum of two integer values. Input: a b Return: The maximum value.
	 *
	 */

	public static int max(int a, int b) {
		if (a > b) {
			return a;
		}

		else {
			return b;
		}

	}

	/*
	 * Function: min Description: Computes the minimum of two integer values. Input: a b Return: The minimum value.
	 *
	 */

	public static int min(int a, int b) {
		if (a < b) {
			return a;
		}

		else {
			return b;
		}
	}

}